namespace xjustiz.core_dotnet.UnitTests.Util;

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Threading.Tasks;
using xjustiz.core_dotnet.Models;
using xjustiz.core_dotnet.Util;
using Xunit;

public class ZipperTests : IDisposable
{
    private readonly string _tempDirectory;

    public ZipperTests()
    {
        _tempDirectory = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        Directory.CreateDirectory(_tempDirectory);
    }

    [Fact]
    public async Task ArchiveToZipStreamAsync_ShouldReturnValidZipStream_WhenCalledWithAttachments()
    {
        // Arrange
        var msg = new UebermittlungSchriftgutobjekteNachricht();

        var file1Path = Path.Combine(_tempDirectory, "test1.txt");
        var file2Path = Path.Combine(_tempDirectory, "test2.txt");
        await File.WriteAllTextAsync(file1Path, "Content 1");
        await File.WriteAllTextAsync(file2Path, "Content 2");

        var exportFiles = new List<string> { file1Path, file2Path };

        // Act
        using var memoryStream = await Zipper.ArchiveToZipStreamAsync(msg, exportFiles);

        // Assert
        Assert.NotNull(memoryStream);
        Assert.True(memoryStream.Length > 0);
        memoryStream.Position = 0;

        using var zipArchive = new ZipArchive(memoryStream, ZipArchiveMode.Read);
        Assert.Equal(3, zipArchive.Entries.Count); // 1 XML + 2 files

        // Validate XML presence - filename generated by GetFileName logic
        var xmlEntry = zipArchive.Entries.FirstOrDefault(e => e.Name.EndsWith(".xml") && e.Name.StartsWith("akte_"));
        Assert.NotNull(xmlEntry);

        var entryNames = string.Join(", ", zipArchive.Entries.Select(e => e.FullName));
        // Validate file 1
        // Zip.cs puts files in "Dokumente/" + fileName. Handle potential backslashes on Windows.
        var file1Entry = zipArchive.Entries.FirstOrDefault(e => e.FullName.Replace('\\', '/') == "Dokumente/test1.txt");
        Assert.True(file1Entry != null, $"Expected 'Dokumente/test1.txt' but found: {entryNames}");
        using (var stream = file1Entry.Open())
        using (var reader = new StreamReader(stream))
        {
            var content = await reader.ReadToEndAsync();
            Assert.Equal("Content 1", content);
        }

        // Validate file 2
        var file2Entry = zipArchive.Entries.FirstOrDefault(e => e.FullName.Replace('\\', '/') == "Dokumente/test2.txt");
        Assert.NotNull(file2Entry);
    }

    [Fact]
    public async Task ArchiveToZipFileAsync_ShouldCreateZipFile_WhenCalledWithAttachments()
    {
        // Arrange
        var msg = new UebermittlungSchriftgutobjekteNachricht();
        var file1Path = Path.Combine(_tempDirectory, "test1.txt");
        await File.WriteAllTextAsync(file1Path, "Content 1");

        var exportFiles = new List<string> { file1Path };
        var destinationZipPath = Path.Combine(_tempDirectory, "test_archive.zip");

        // Act
        var zipPath = await Zipper.ArchiveToZipFileAsync(msg, destinationZipPath, exportFiles);

        // Assert
        Assert.Equal(destinationZipPath, zipPath);
        Assert.True(File.Exists(zipPath));

        using var fileStream = File.OpenRead(zipPath);
        using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);

        Assert.Equal(2, zipArchive.Entries.Count); // 1 XML + 1 file

        var xmlEntry = zipArchive.Entries.FirstOrDefault(e => e.Name.EndsWith(".xml") && e.Name.StartsWith("akte_"));
        Assert.NotNull(xmlEntry);

        var entryNames = string.Join(", ", zipArchive.Entries.Select(e => e.FullName));
        var file1Entry = zipArchive.Entries.FirstOrDefault(e => e.FullName.Replace('\\', '/') == "Dokumente/test1.txt");
        Assert.True(file1Entry != null, $"Expected 'Dokumente/test1.txt' but found: {entryNames}");
    }

    [Fact]
    public async Task ArchiveToZipStreamAsync_ShouldWork_WithoutAttachments()
    {
        // Arrange
        var msg = new UebermittlungSchriftgutobjekteNachricht();

        // Act
        using var memoryStream = await Zipper.ArchiveToZipStreamAsync(msg, null);

        // Assert
        Assert.NotNull(memoryStream);
        memoryStream.Position = 0;

        using var zipArchive = new ZipArchive(memoryStream, ZipArchiveMode.Read);
        Assert.Single(zipArchive.Entries); // 1 XML only

        var xmlEntry = zipArchive.Entries.FirstOrDefault(e => e.Name.EndsWith(".xml"));
        Assert.NotNull(xmlEntry);
    }

    [Fact]
    public async Task ArchiveToZipFileAsync_ShouldContainCorrectFileName_WhenAktenzeichenIsSet()
    {
        // Arrange
        var msg = new UebermittlungSchriftgutobjekteNachricht();
        msg.Kopf.AktenzeichenAbsender = ["AZ-Test-123"];

        var destinationZipPath = Path.Combine(_tempDirectory, "test_archive_az.zip");

        // Act
        await Zipper.ArchiveToZipFileAsync(msg, destinationZipPath);

        // Assert
        Assert.True(File.Exists(destinationZipPath));

        using var fileStream = File.OpenRead(destinationZipPath);
        using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);

        var xmlEntry = zipArchive.Entries.FirstOrDefault(e => e.Name == "akte_AZ-Test-123.xml");

        Assert.NotNull(xmlEntry);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            if (Directory.Exists(_tempDirectory))
            {
                // Recursive delete
                Directory.Delete(_tempDirectory, true);
            }
        }
    }
}